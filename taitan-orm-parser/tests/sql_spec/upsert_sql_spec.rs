use taitan_orm_parser::{DatabaseType, SqlGenerator, SqlType};

use crate::common::ExpectSql;
use crate::common::TableDefGenerator;

fn get_expected_sql_mysql() -> &'static [&'static str] {
    &[
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"a,b,c\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",d\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; if ! self . d . is_none () { s . push_str (\"d=VALUES(d)\" . as_ref ()) ; } if ! self . e . is_none () { if has_prev { s . push (',') ; } else { has_prev = true ; } s . push_str (\"user_name=VALUES(user_name)\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO user ({}) VALUES({}) ON DUPLICATE KEY UPDATE {}\" , fields , marks , upsert_sets)",
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name,`select`,`and`\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name=VALUES(name),`select`=VALUES(`select`),`and`=VALUES(`and`)\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age=VALUES(age)\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name=VALUES(user_name)\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO user ({}) VALUES({}) ON DUPLICATE KEY UPDATE {}\" , fields , marks , upsert_sets)"
    ]
}

fn get_expected_sql_postgres() -> &'static [&'static str] {
    &[
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"a,b,c\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",d\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let primarys = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"a,b,c\") ; has_prev = true ; ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; if ! self . d . is_none () { s . push_str (\"d=EXCLUDED.d\" . as_ref ()) ; } if ! self . e . is_none () { if has_prev { s . push (',') ; } else { has_prev = true ; } s . push_str (\"user_name=EXCLUDED.user_name\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO \\\"user\\\" ({}) VALUES({}) ON CONFLICT ({}) DO UPDATE SET {}\" , fields , marks , primarys , upsert_sets)",
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name,\\\"select\\\",\\\"and\\\"\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let primarys = { let mut s = String :: default () ; let mut has_prev = false ; ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name=EXCLUDED.name,\\\"select\\\"=EXCLUDED.\\\"select\\\",\\\"and\\\"=EXCLUDED.\\\"and\\\"\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age=EXCLUDED.age\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name=EXCLUDED.user_name\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO \\\"user\\\" ({}) VALUES({}) ON CONFLICT ({}) DO UPDATE SET {}\" , fields , marks , primarys , upsert_sets)"
    ]
}

fn get_expected_sql_sqlite() -> &'static [&'static str] {
    &[
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"a,b,c\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",d\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . d . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . e . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let primarys = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"a,b,c\") ; has_prev = true ; ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; if ! self . d . is_none () { s . push_str (\"d=EXCLUDED.d\" . as_ref ()) ; } if ! self . e . is_none () { if has_prev { s . push (',') ; } else { has_prev = true ; } s . push_str (\"user_name=EXCLUDED.user_name\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO user ({}) VALUES({}) ON CONFLICT ({}) DO UPDATE SET {}\" , fields , marks , primarys , upsert_sets)",
        "let fields = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name,\\\"select\\\",\\\"and\\\"\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name\" . as_ref ()) ; } ; s } ; let marks = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"?,?,?\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",?\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",?\" . as_ref ()) ; } ; s } ; let primarys = { let mut s = String :: default () ; let mut has_prev = false ; ; s } ; let upsert_sets = { let mut s = String :: default () ; let mut has_prev = false ; s . push_str (\"name=EXCLUDED.name,\\\"select\\\"=EXCLUDED.\\\"select\\\",\\\"and\\\"=EXCLUDED.\\\"and\\\"\") ; has_prev = true ; if ! self . age . is_none () { s . push_str (\",age=EXCLUDED.age\" . as_ref ()) ; } if ! self . primary . is_none () { s . push_str (\",user_name=EXCLUDED.user_name\" . as_ref ()) ; } ; s } ; format ! (\"INSERT INTO user ({}) VALUES({}) ON CONFLICT ({}) DO UPDATE SET {}\" , fields , marks , primarys , upsert_sets)"
    ]
}

#[test]
fn upsert_sql_spec() {
    let table_def_generator = TableDefGenerator::new();
    table_def_generator.validate(DatabaseType::MySql, SqlType::Upsert, get_expected_sql_mysql());
    table_def_generator.validate(DatabaseType::Postgres, SqlType::Upsert, get_expected_sql_postgres());
    table_def_generator.validate(DatabaseType::Sqlite, SqlType::Upsert, get_expected_sql_sqlite());
}
